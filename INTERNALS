About the NSS 'buffer' and how I utilize it

The area of memory that's allocated by the NSS system and handed to us
for storing data, called 'buffer', is the *ONLY* way this library
should make use of memory to return strings and whatnot.  For example,
we do *NOT* do this:
    pw->pw_name = strdup(username);
The memory that strdup allocates would never be freed and we'd have a leak.
That wouldn't be a big deal for most programs; on the other hand, daemons
that run 24x7 and use any of these routines would bloat until all your
system memory was used.
Instead, we copy 'username' to a free spot in 'buffer' and make sure it's
NULL-terminated.  Then we set pw->pw_name's pointer to point to the
address space where we just copied 'username' to.
If 'buffer' isn't big enough (not likely; we're given 1024 bytes to start),
we set 'errno' to ERANGE and return NSS_TRYAGAIN.  This tells the
nss system to realloc buffer with more space (2x the last value) and
retry the call.  That way we're pretty well guaranteed we've got enough
space to work with.

Presently, I memset(buffer, 0, buflen).  This makes it relatively
easy for me to insert strings and have them automatically NULL-terminated.
Data is arranged pointers first, then general data (usually strings).
For example:

01234567890123456789012345678901234567890
username password gecos ... 

(where spaces are nulls)

or
01234567890123456789012345678901234567890
*ptr*ptrNULLstring1 string2

This is for a **char type.  The main pointer in the structure points
at memory spot 0 where *ptr number one is.  ptr #1 points at string1.
ptr #2 points at string2.  The NULL ptr (4 bytes of NULLs) means the
'list' of pointers has ended (that's how a **char is stored - a
NULL-terminated list of pointers).


